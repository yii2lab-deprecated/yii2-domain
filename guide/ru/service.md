Сервис
======

Сервисный слой содержит бизнес-логику. 
Это глобально доступный слой, который может быть вызван из любой части приложения.

Содержимое методов сервиса обычно содержит смысл, понятный не только программистам.

Если писать метод в сервисе не на PHP, а на Русском:

```
Редактировать сущность:
    Взять у хранилища сущность по ее ID.
    Изменить некоторые атрибуты этой сущности.
    Передать сущность обратно хранилищу для сохранения.
    Уведомить об этом пользователя.
```

## Цель

* Собрать и описать бизнес-логину в одном месте.
* предоставить понятный интерфейс
* Изолировать бизнес-логику от других логик.
* Облегчить понимание схемы работы кода
* максимально абстрагироваться от деталей реализации
* Решить бизнес-задачу

## Особенности

* Сервис может быть вызван из любого места
* Сервис может быть легко заменен другим сервисом, имеющим тот же интерфейс.
* Сервис не имеет состояния.
* Сервис работает с данными только посредством репозитория, абстрагируясь от деталей хранения
* Имеет единственный экземпляр
* в некоторых случаях, сервис может просто зеркалить методы хранилища не имея бизнес логики

## Пример кода

Пример обращения к методу сервиса:

```php
Yii::$app->account->auth->logout();
```

Где 
* `account` - имя домена
* `auth` - сервис аутентификации
* `logout` - метод выхода из аккаунта

## Базовые классы

Есть 2 базовых класса для сервиса:

* BaseService
* ActiveBaseService

Если у нас стандартная сущность, к которой применимы операции CRUD,
то используем ActiveBaseService.
Такой сервис предоставляет стандартные методы для CRUD.
При использовании ActiveBaseService, 
репозиторий тоже должен уметь работать с CRUD.

Если случай не стандартный, то расширяемся от BaseService
и реализуем нужные методы.

### CRUD-операции

Пример сервиса для CRUD:

```php
class CityService extends ActiveBaseService {
	
}
```

Да-да, я не ошибся, пустой класс.
Если посмотреть, от чего мы его раширяем, то можно увидеть реализацию методов:

* isExistsById($id)
* isExists($condition)
* one(Query $query = null)
* oneById($id, Query $query = null)
* all(Query $query = null)
* count(Query $query = null)

Это методы для CRUD-операций.

## События

Если вы делаете собственные методы, то должны их обрамлять событиями:

```php
$this->beforeAction(self::EVENT_VIEW);
...
return $this->afterAction(self::EVENT_VIEW, $result);
```

Это нужно для обработки событий до и после.

Если оборачиваете стандартный CRUD-метод, то вставлять вызовы событий необязательно,
так как в стандартном CRUD-методе они уже есть.

Например, через событие производится обработка прав доступа.

## Права доступа

Вы можете устанавливать права доступа на методы чтения и изменения.
Для этого объявляем правила:

```php
class CityService extends ActiveBaseService {
	
	public function access() {
    	return [
    		['geo.city.manage', ['create', 'update', 'delete']],
    		['geo.city.delete', ['delete']],
    	];
    }
}
```
